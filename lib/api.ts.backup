import { MasterTask, TaskInstance, Position, PublicHoliday } from './types'
import { supabase } from './supabase'

const API_BASE_URL = '/api'

// Allow external setting of auth token for direct integration with auth context
let externalAuthToken: string | null = null

export function setApiAuthToken(token: string | null) {
  externalAuthToken = token
  console.log('API client - External auth token set:', {
    hasToken: !!token,
    tokenLength: token?.length,
    tokenPreview: token ? token.substring(0, 20) + '...' : 'none'
  })
}

class ApiError extends Error {
  constructor(public status: number, message: string) {
    super(message)
    this.name = 'ApiError'
  }
}

async function getAuthHeaders(): Promise<Record<string, string>> {
  // First check if we have an external auth token set
  if (externalAuthToken) {
    console.log('API client - Using external auth token')
    return {
      'Authorization': `Bearer ${externalAuthToken}`
    }
  }

  // Get the session from the existing Supabase client
  if (typeof window !== 'undefined') {
    console.log('API client - Getting session from supabase...')
    
    // Try multiple methods to get the session
    let session = null
    let sessionError = null
    
    // Method 1: Direct session retrieval
    try {
      const result = await supabase.auth.getSession()
      session = result.data.session
      sessionError = result.error
      console.log('API client - Direct session result:', {
        sessionExists: !!session,
        error: sessionError?.message
      })
    } catch (error) {
      console.error('API client - Error getting session:', error)
    }
    
    // Method 2: If no session, try to refresh
    if (!session) {
      console.log('API client - No session found, attempting refresh...')
      try {
        const refreshResult = await supabase.auth.refreshSession()
        session = refreshResult.data.session
        console.log('API client - Refresh session result:', {
          sessionExists: !!session,
          error: refreshResult.error?.message
        })
      } catch (error) {
        console.error('API client - Error refreshing session:', error)
      }
    }
    
    // Method 3: Try to get user directly
    if (!session) {
      console.log('API client - Attempting to get user directly...')
      try {
        const userResult = await supabase.auth.getUser()
        console.log('API client - Direct user result:', {
          userExists: !!userResult.data.user,
          error: userResult.error?.message
        })
        
        // If we have a user but no session, there might be an issue
        if (userResult.data.user && !userResult.error) {
          console.log('API client - User exists but no session, checking localStorage...')
          
          // Check if there's a session in localStorage with various possible keys
          const possibleKeys = [
            'supabase.auth.token',
            `sb-${process.env.NEXT_PUBLIC_SUPABASE_URL?.split('//')[1]?.split('.')[0]}-auth-token`,
            'sb-auth-token'
          ]
          
          for (const key of possibleKeys) {
            const storedSession = localStorage.getItem(key)
            if (storedSession) {
              try {
                const parsed = JSON.parse(storedSession)
                console.log('API client - Found stored session with key:', key, {
                  hasAccessToken: !!parsed.access_token,
                  tokenLength: parsed.access_token?.length
                })
                
                if (parsed.access_token) {
                  return {
                    'Authorization': `Bearer ${parsed.access_token}`
                  }
                }
              } catch (parseError) {
                console.error('API client - Error parsing stored session:', parseError)
              }
            }
          }
          
          // Also check all localStorage keys for debugging
          console.log('API client - All localStorage keys:', Object.keys(localStorage))
        }
      } catch (error) {
        console.error('API client - Error getting user:', error)
      }
    }
    
    console.log('API client - Final session info:', {
      sessionExists: !!session,
      tokenExists: !!session?.access_token,
      userEmail: session?.user?.email,
      tokenLength: session?.access_token?.length,
      userId: session?.user?.id,
      sessionError: sessionError?.message,
      tokenPreview: session?.access_token ? session.access_token.substring(0, 30) + '...' : 'none',
      expiresAt: session?.expires_at ? new Date(session.expires_at * 1000).toISOString() : 'none',
      isExpired: session?.expires_at ? session.expires_at < Date.now() / 1000 : 'unknown'
    })
    
    if (sessionError) {
      console.error('API client - Session error:', sessionError)
    }
    
    if (session?.access_token) {
      console.log('API client - Auth header will be set')
      return {
        'Authorization': `Bearer ${session.access_token}`
      }
    } else {
      console.log('API client - No access token available')
    }
  } else {
    console.log('API client - Not in browser environment')
  }
  
  return {}
}

async function waitForAuth(maxAttempts = 5, delayMs = 1000): Promise<string | null> {
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    console.log(`API client - Auth attempt ${attempt + 1}/${maxAttempts}`)
    const authHeaders = await getAuthHeaders()
    
    if (authHeaders.Authorization) {
      console.log('API client - Auth token found on attempt', attempt + 1)
      return authHeaders.Authorization
    }
    
    if (attempt < maxAttempts - 1) {
      console.log(`API client - No auth token, waiting ${delayMs}ms before retry...`)
      await new Promise(resolve => setTimeout(resolve, delayMs))
    }
  }
  
  console.log('API client - Failed to get auth token after', maxAttempts, 'attempts')
  return null
}

async function apiRequest<T>(endpoint: string, options?: RequestInit): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`
  
  // Try to get auth headers with retries
  let authToken = null
  const authHeaders = await getAuthHeaders()
  
  if (!authHeaders.Authorization) {
    console.log('API client - No immediate auth token, waiting for auth...')
    authToken = await waitForAuth()
    
    if (!authToken) {
      console.error('API client - Could not obtain auth token, request may fail')
    }
  } else {
    authToken = authHeaders.Authorization
  }
  
  const finalHeaders = {
    'Content-Type': 'application/json',
    ...(authToken ? { 'Authorization': authToken } : {}),
    ...options?.headers,
  }
  
  console.log('API client - Making request to:', endpoint)
  console.log('API client - Auth headers:', {
    hasAuthHeader: !!finalHeaders.Authorization,
    authHeaderLength: finalHeaders.Authorization?.length
  })
  
  const response = await fetch(url, {
    headers: finalHeaders,
    ...options,
  })

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }))
    console.error('API client - Request failed:', {
      endpoint: endpoint,
      status: response.status,
      statusText: response.statusText,
      error: errorData.error,
      errorData: errorData,
      hadAuthToken: !!finalHeaders.Authorization,
      authTokenLength: finalHeaders.Authorization?.length,
      authTokenPreview: finalHeaders.Authorization ? finalHeaders.Authorization.substring(0, 30) + '...' : 'none',
      responseHeaders: Object.fromEntries([...response.headers.entries()]),
      requestHeaders: finalHeaders
    })
    throw new ApiError(response.status, errorData.error || 'API request failed')
  }

  return response.json()
}

// Positions API
export const positionsApi = {
  getAll: (): Promise<Position[]> => apiRequest('/positions'),
  
  create: (data: Omit<Position, 'id' | 'created_at' | 'updated_at'>): Promise<Position> =>
    apiRequest('/positions', {
      method: 'POST',
      body: JSON.stringify(data),
    }),
}

// Master Tasks API
export const masterTasksApi = {
  getAll: (params?: { position_id?: string; status?: string }): Promise<MasterTask[]> => {
    const searchParams = new URLSearchParams()
    if (params?.position_id) searchParams.append('position_id', params.position_id)
    if (params?.status) searchParams.append('status', params.status)
    
    const query = searchParams.toString()
    return apiRequest(`/master-tasks${query ? `?${query}` : ''}`)
  },
  
  getById: (id: string): Promise<MasterTask> => apiRequest(`/master-tasks/${id}`),
  
  create: (data: Omit<MasterTask, 'id' | 'created_at' | 'updated_at' | 'positions'>): Promise<MasterTask> =>
    apiRequest('/master-tasks', {
      method: 'POST',
      body: JSON.stringify(data),
    }),
  
  update: (id: string, data: Partial<MasterTask>): Promise<MasterTask> =>
    apiRequest(`/master-tasks/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    }),
  
  delete: (id: string): Promise<void> =>
    apiRequest(`/master-tasks/${id}`, {
      method: 'DELETE',
    }),
}

// Task Instances API
export const taskInstancesApi = {
  getAll: (params?: { 
    date?: string; 
    dateRange?: string;
    position_id?: string; 
    status?: string;
    category?: string;
  }): Promise<any[]> => {
    const searchParams = new URLSearchParams()
    if (params?.date) searchParams.append('date', params.date)
    if (params?.dateRange) searchParams.append('dateRange', params.dateRange)
    if (params?.position_id) searchParams.append('position_id', params.position_id)
    if (params?.status) searchParams.append('status', params.status)
    if (params?.category) searchParams.append('category', params.category)
    
    const query = searchParams.toString()
    return apiRequest(`/task-instances${query ? `?${query}` : ''}`)
  },
  
  getById: (id: string): Promise<any> => apiRequest(`/task-instances/${id}`),
  
  update: (id: string, data: { 
    status?: string; 
    completed_by?: string; 
    action?: string 
  }): Promise<TaskInstance> =>
    apiRequest(`/task-instances/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    }),
  
  create: (data: {
    master_task_id: string;
    instance_date: string;
    due_date: string;
    due_time: string;
  }): Promise<TaskInstance> =>
    apiRequest('/task-instances', {
      method: 'POST',
      body: JSON.stringify(data),
    }),
}

// Public Holidays API
export const publicHolidaysApi = {
  getAll: (params?: { year?: string; region?: string }): Promise<PublicHoliday[]> => {
    const searchParams = new URLSearchParams()
    if (params?.year) searchParams.append('year', params.year)
    if (params?.region) searchParams.append('region', params.region)
    
    const query = searchParams.toString()
    return apiRequest(`/public-holidays${query ? `?${query}` : ''}`)
  },
  
  create: (data: Omit<PublicHoliday, 'created_at'>): Promise<PublicHoliday> =>
    apiRequest('/public-holidays', {
      method: 'POST',
      body: JSON.stringify(data),
    }),
  
  delete: (date: string): Promise<void> =>
    apiRequest('/public-holidays', {
      method: 'DELETE',
      body: JSON.stringify({ date }),
    }),
}

// Auth testing API
export const authTestApi = {
  test: (): Promise<any> => apiRequest('/auth/test')
}

export { ApiError }